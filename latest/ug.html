<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>User Guide · ACME.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="../versions.js"></script></head><body><nav class="toc"><h1>ACME.jl</h1><form class="search" action="search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="gettingstarted.html">Getting Started</a></li><li class="current"><a class="toctext" href="ug.html">User Guide</a><ul class="internal"><li><a class="toctext" href="#Element-Creation-1">Element Creation</a></li><li><a class="toctext" href="#Circuit-Description-1">Circuit Description</a></li><li><a class="toctext" href="#Model-Creation-and-Use-1">Model Creation and Use</a></li><li><a class="toctext" href="#Solvers-1">Solvers</a></li></ul></li><li><a class="toctext" href="elements.html">Element Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="ug.html">User Guide</a></li></ul><a class="edit-page" href="https://github.com/HSU-ANT/ACME.jl/tree/acf2a40f7bd212a2cf2844c405b7992e42f1f803/docs/src/ug.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="User-Guide-1" href="#User-Guide-1">User Guide</a></h1><h2><a class="nav-anchor" id="Element-Creation-1" href="#Element-Creation-1">Element Creation</a></h2><p>All circuit elements are created by calling corresponding functions; see the <a href="elements.html#Element-Reference-1">Element Reference</a> for details.</p><h2><a class="nav-anchor" id="Circuit-Description-1" href="#Circuit-Description-1">Circuit Description</a></h2><p>Circuits are described using <code>Circuit</code> instances, created with <code>Circuit()</code>. Once a <code>Circuit</code> and elements have been created, the elements can be added to the circuit using the <code>add!</code> method:</p><pre><code class="language-Julia">r = resistor(1e3);
c = capacitor(22e-9);
circ = Circuit();
add!(circ, r)
add!(circ, c)</code></pre><p>Multiple elements can be added also be at once; the last two lines could have been replaced with <code>add!(circ, r, c)</code>.</p><p>In many cases, however, explicitly calling <code>add!</code> is not necessary. All that is needed is <code>connect!</code>, which connects two (or more) element pins. The elements to which these pins belong are automatically added to the circuit if needed. The only reason to explicitly call <code>add!</code> is to control the insertion order of sources or sinks, which determines the order in which inputs have to be provided and outputs are obtained.</p><p>Pins are obtained from elements using <code>[]</code>-style indexing, i.e. <code>r[1]</code> gives the first pin of the resistor defined above. So this connects the first pin of the resistor with the first pin of the capacitor:</p><pre><code class="language-Julia">connect!(circ, r[1], c[1])</code></pre><p>Further connections involving the same pins are possible and will <em>not</em> replace existing ones. So this will effectively shorten the resistor, because now both of its pins are connected to <code>c[1]</code>:</p><pre><code class="language-Julia">connect!(circ, r[2], c[1])</code></pre><p>Note that not all elements have numbered pins. For elements with polarity, they may be called <code>+</code> and <code>-</code>, while a bipolar transistor has pins <code>base</code>, <code>collector</code>, and <code>emitter</code>. The pins provided by each type of element are described in the <a href="elements.html#Element-Reference-1">Element Reference</a>. Internally, the pin designators are <code>Symbol</code>s. However, not all symbols are conveniently entered in Julia: <code>:base</code> is nice, <code>symbol(&quot;1&quot;)</code> less so. Therefore, the <code>[]</code> operation on elements also accepts integers and strings and converts them to the respective <code>Symbol</code>s. So <code>r[symbol(&quot;1&quot;)]</code> is equivalent to <code>r[1]</code> and (assuming <code>d</code> to be a diode) <code>d[:+]</code> is equivalent to <code>d[&quot;+&quot;]</code> (but <code>d[+]</code> does not work).</p><p>In addition to pins, <code>connect!</code> also accepts <code>Symbol</code>s as input. This creates named nets which may improve readability for nets with many conneted pins:</p><pre><code class="language-Julia">connect!(c[2], :gnd)
connect!(r[2], :gnd)</code></pre><p>Again, this only adds connections, keeping existing ones, so together with the above snippets, now all pins are connected to each other and to net a named <code>gnd</code>. It is even possible to connect multiple named nets to each other, though this will only rarely be useful.</p><h2><a class="nav-anchor" id="Model-Creation-and-Use-1" href="#Model-Creation-and-Use-1">Model Creation and Use</a></h2><p>A <code>Circuit</code> only stores elements and information about their connections. To simulate a circuit, a model has to be derived from it. This can be as simple as:</p><pre><code class="language-Julia">model = DiscreteModel(circ, 1/44100)</code></pre><p>Here, <code>1/44100</code> denotes the sampling interval, i.e. the reciprocal of the sampling rate at which the model should run. Optionally, one can specify the solver to use for solving the model&#39;s non-linear equation:</p><pre><code class="language-Julia">model = DiscreteModel(circ, 1/44100, HomotopySolver{SimpleSolver})</code></pre><p>See <a href="ug.html#Solvers-1">Solvers</a> for more information about the available solvers.</p><p>Once a model is created, it can be run:</p><pre><code class="language-Julia">y = run!(model, u)</code></pre><p>The input <code>u</code> is matrix with one row for each of the circuit&#39;s inputs and one column for each time step to simulate. Likewise, the output <code>y</code> will be a matrix with one row for each of the circuit&#39;s outputs and one column for each simulated time step. The order of the rows will correspond to the order in which the respective input and output elements were added to the <code>Circuit</code>. To simulate a circuit without inputs, a matrix with zero rows may be passed:</p><pre><code class="language-Julia">y = run!(model, zeros(0, 100))</code></pre><p>The internal state of the model (e.g. capacitor charges) is preserved accross calls to <code>run!</code>.</p><p>Each invocation of <code>run!</code> in this way has to allocate some memory as temporary storage. To avoid this overhead when running the same model for many small input blocks, a <code>ModelRunner</code> instance can be created explicitly:</p><pre><code class="language-Julia">runner = ModelRunner(model, false)
run!(runner, y, u)</code></pre><p>By using a pre-allocated output <code>y</code> as in the example, allocations in <code>run!</code> are reduced to a minimum.</p><p>Upon creation of a <code>DiscreteModel</code>, its internal states (e.g. capacitor charges) are set to zero. It is also possible to set the states to a steady state (if one can be found) with:</p><pre><code class="language-Julia">steadystate!(model)</code></pre><p>This is often desirable for circuits where bias voltages are only slowly obtained after turning them on.</p><h2><a class="nav-anchor" id="Solvers-1" href="#Solvers-1">Solvers</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ACME.SimpleSolver" href="#ACME.SimpleSolver"><code>ACME.SimpleSolver</code></a> — <span class="docstring-category">Constant</span>.</div><div><pre><code class="language-none">SimpleSolver</code></pre><p>The <code>SimpleSolver</code> is the simplest available solver. It uses Newton iteration which features fast local convergence, but makes no guarantees about global convergence. The initial solution of the iteration is obtained by extrapolating the last solution found (or another solution provided externally) using the available Jacobians. Due to the missing global convergence, the <code>SimpleSolver</code> is rarely useful as such.</p></div><a class="source-link" target="_blank" href="https://github.com/HSU-ANT/ACME.jl/tree/acf2a40f7bd212a2cf2844c405b7992e42f1f803/src/solvers.jl#L97-L106">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ACME.HomotopySolver" href="#ACME.HomotopySolver"><code>ACME.HomotopySolver</code></a> — <span class="docstring-category">Constant</span>.</div><div><pre><code class="language-none">HomotopySolver{BaseSolver}</code></pre><p>The <code>HomotopySolver</code> extends an existing solver (provided as the type parameter) by applying homotopy to (at least theoretically) ensure global convergence. It can be combined with the <code>SimpleSolver</code> as <code>HomotopySolver{SimpleSolver}</code> to obtain a useful Newton homtopy solver with generally good convergence properties.</p></div><a class="source-link" target="_blank" href="https://github.com/HSU-ANT/ACME.jl/tree/acf2a40f7bd212a2cf2844c405b7992e42f1f803/src/solvers.jl#L194-L202">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ACME.CachingSolver" href="#ACME.CachingSolver"><code>ACME.CachingSolver</code></a> — <span class="docstring-category">Constant</span>.</div><div><pre><code class="language-none">CachingSolver{BaseSolver}</code></pre><p>The <code>CachingSolver</code> extends an existing solver (provided as the type parameter) by storing found solutions in a k-d tree to use as initial solutions in the future. Whenever the underlying solver needs more than a preset number of iterations (defaults to five), the solution will be stored. Storing new solutions is a relatively expensive operation, so until the stored solutions suffice to ensure convergence in few iterations throughout, use of a <code>CachingSolver</code> may actually slow things down.</p><p>See <a href="http://www.eurasip.org/Proceedings/Eusipco/Eusipco2016/papers/1570255150.pdf">M. Holters, U. Zölzer, &quot;A k-d Tree Based Solution Cache for the Non-linear Equation of Circuit Simulations&quot;</a> for a more detailed discussion.</p></div><a class="source-link" target="_blank" href="https://github.com/HSU-ANT/ACME.jl/tree/acf2a40f7bd212a2cf2844c405b7992e42f1f803/src/solvers.jl#L259-L273">source</a><br/></section><p>The default solver used is a <code>HomotopySolver{CachingSolver{SimpleSolver}}</code>.</p><footer><hr/><a class="previous" href="gettingstarted.html"><span class="direction">Previous</span><span class="title">Getting Started</span></a><a class="next" href="elements.html"><span class="direction">Next</span><span class="title">Element Reference</span></a></footer></article></body></html>
